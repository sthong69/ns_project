# BackEnd Vrac'IMT

Vrac'IMT est un projet étudiant visant à créer une application pour les étudiants d'IMT Atlantique à Brest. Cette application permettrait aux étudiants d'avoir toutes les informations sur la vente hebdomadaire de produits en vrac à la cafétéria, de constituer des paniers virtuels et de prévoir leur budget. Les gestionnaires du Vrac pourront également mieux gérer leurs stocks grâce aux paniers validés par les clients. L'objectif futur est d'inclure des produits périssables pour éviter tout gaspillage alimentaire.

## Représentation des données 
Les différentes données de notre application se doivent d’être organisées soigneusement afin qu’elles puissent être restituées de la façon la plus efficace possible. Le choix s’est orienté vers une base de données SQL permettant une mise à disposition en ligne des données. Certes, nous aurions pu simplement utiliser un fichier texte avec des données finement formatées au type JSON mais les bases de données apportent un certain nombre d’outils et de vérifications qui limitent au mieux les erreurs de références entre les différentes informations stockées.

Dans un premier temps, nous avons conceptualisé une architecture de stockage de données à partir des besoins que nous avons. En effet, il nous est nécessaire de stocker chaque produit ainsi que chacune de ses caractéristiques ; nous créons donc une table Products. Pour la version Première de notre application, cette table sera la première créée et la seule utilisée ; l’application sera plus un catalogue de produits qu’une application de réservation, à ce stade. Les attributs importants à détailler sont les suivants : `image`, `unit` et `bottle_equivalent`. 
Afin d’afficher une illustration pour chaque produit, nous devons stocker en ligne une image. Ce choix d’externaliser le fichier image a deux avantages : cela réduit la taille de l’application à installer et cela permet de faciliter la mise à jour de l’image. L’unique inconvénient est que l’utilisateur doit être connecté à Internet pour pouvoir afficher et télécharger l’image. Or, aujourd’hui tous les téléphones, ou presque, sont en permanence connecté à Internet, ce n’est donc pas un réel inconvénient. De plus, on pourrait nous reprocher le temps de téléchargement de l’image quand la connexion réseau est faible ; encore une fois, ce problème n’en est pas un : les images seront de taille moyenne à petite donc légères et de plus, au risque de nous répéter, la connexion internet sera dans la majorité des cas suffisante pour garantir le temps d’ouverture de l’application.
Le deuxième attribut un tant soit peu « spécial » est l’unité (`unit`). Nous avons fait le choix de stocker l’unité au format texte et ainsi de pouvoir le récupérer de la base de données pour l’afficher directement dans l’application. Ainsi, cet attribut ne peut prendre les valeurs "kg", "L" ou "u" pour un article vendu à la masse, au volume ou bien à l’unité.
Le dernier attribut spécifique aux besoins que nous avons est l’équivalent en masse ou en volume d’une bouteille vide (`bottle_equivalent`) d’un litre qui est utilisée au Vrac comme contenant.

Dans un second temps, la problématique est de répertorier les achats des clients. A cet effet, le choix initial serait d’avoir une table contenant les paniers créés par les différents clients. Cette table contiendrait donc un attribut de type liste et contenant la liste des produits achetés par le client ainsi qu’une liste contenant les quantités sélectionnées par le client. Or, les listes en SQL ne constituent pas un type d’attribut respectant les règles de première forme normale. Ainsi, la solution préférée sera d’utiliser une table d’opération (`Operations`) et une table de paniers (`Cart`).

Enfin, les clients seront à terme, identifiés sur l’application, afin qu’ils puissent retrouver leurs paniers, obtenir l’historique de leurs achats, etc. il faut donc répertorier les clients grâce à la table `Clients`.
 
Figure 2 : Schéma conceptuel de la base de données

Ce schéma conceptuel, visible sur la Figure 2, permet de mieux visualiser l’organisation des données au sein de l’application. Certes, cette architecture est simple mais elle contient quelques subtilités. Par exemple, l’attribut `retrieved` est une date précisant le moment auquel le panier a été récupéré. De même, l’attribut `payment_method` correspond au moyen de paiement du panier. Pour ces attributs, s’ils sont indéfinis ou nuls, alors cela signifie respectivement que le panier n’a pas été récupéré ou bien qu’il n’a pas été payé. Cette astuce permet d’éviter la redondance dans la base de données et donc de respecter les règles de formes normales.
